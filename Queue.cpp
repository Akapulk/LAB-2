#include "Queue.h"
#include <iostream>

using namespace std;

//конструктор с параметром
Queue::Queue(int count) //передаем размер создаваемой очереди
{
	for (int i = 0; i < count; ++i) //добавляем count элементов в очередь
	{
		int value = rand() % 21 - 10; //берем рандомное значение от -10 до 10
		push(value); //вызываем метод добавления элемента в очередь и передаем ему полученное значение
	}
}

//конструктор копирования
Queue::Queue(const Queue & ob)
{
	Node *tmp = ob.tail; //указатель-помощник на очередь, которую будем копировать, так как нельзя менять tail
	this->size = 0; //в объекте, в который будем копировать устанавливаем размер очереди равным 0
	int *ptr = new int[ob.size]; //массив для записи туда значений из очереди, которую будем копировать

	//копируем элементы в массив, так как двигаться по очереди можно только в обратном порядке
	for (int i = 0; i < ob.size; ++i)
	{
		ptr[i] = tmp->data; //записываем значение
		tmp = tmp->prev; //передвигаем указатель на предыдущий элемент
	}

	//копируем элементы в новый объект в нужном порядке
	for (int i = ob.size - 1; i >= 0; --i)
		this->push(ptr[i]); //добавляем элемент

	delete[] ptr; //выделяли память динамически, значит надо её отчистить
}

//деструктор
Queue::~Queue()
{
	Node *tmp; //указаетль-помощник
	for (int i = 0; i < size; ++i) //удаляем все size элементов из очереди
	{
		tmp = tail; //запоминаем указатель на последний элемент
		tail = tail->prev; //передвигаем tail на предпоследний элемент
		delete tmp; //удаляем последний элемент
	}
	size = 0; //очередь пуста
}

//взятие размера очереди
int Queue::getSize()
{
	return size; //просто возвращаем размер очереди
}

//метод добавления
void Queue::push(int data)
{
	Node* tmp = new Node; //создаем новый элемен, и на него будет указывать указатель tmp
	tmp->data = data; //записываем в поле data значение, которое мы передали
	tmp->prev = tail; // новый элемент указывает на последний в очереди элемент, т.е. перед ним
	tail = tmp; // хвост указывает на новый элемент
	++size; //увеличиваем количество элементов в очереди;
}

//вывод очереди
void Queue::show()
{
	Node *tmp = tail; //указатель-помощник
	int *ptr = new int[size]; //массив для записи туда значений из очереди

	//копируем элементы в массив, так как двигаться по очереди можно только в обратном порядке
	for (int i = 0; i < size; ++i)
	{
		ptr[i] = tmp->data; //записываем значение
		tmp = tmp->prev; //передвигаем указатель на предыдущий элемент
	}

	//выводим элементы в нужном порядке
	for (int i = size - 1; i >= 0; --i)
		cout << ptr[i] << " "; //выводим элемент

	delete[] ptr; //выделяли память динамически, значит надо её отчистить
}

//перегрузка оператора присваивания, объект слева текущий (this), объект справа передан в качестве параметра
Queue & Queue::operator=(const Queue & ob)
{
	Node *tmp1 = tail; //указатель на очередь слева от =
	Node *tmp2 = ob.tail; //указатель на очередь справа от =

	for (int i = 0; i < size; ++i) //пробегаемся по всей очереди
	{
		tmp1->data = tmp2->data; //присваиваем элементу очереди слева значение элемента очереди справа
		tmp1 = tmp1->prev; //передвигаем указатель на предыдущий элемент очереди слева
		tmp2 = tmp2->prev; //передвигаем указатель на предыдущий элемент очереди справа
	}

	return *this; //возвращаем объект слева от =, то есть это текущий объект
}

//перегрузка оператора отрицание
//так как мы возвращаем локальный объект, то возвращаем по значению
Queue Queue::operator!()
{
	/*так как нам не надо менять сам объект, для которого вызвался этот оператор (this), то мы создаем локальный объекк, в 
	который и будем записывать изменения this объекта*/
	Queue res(*this); //создаем копию объекта с помощью конструктора копирования
	Node *tmp = res.tail; //указатель на конец очереди локального объекта 
	for (int i = 0; i < size; ++i) //пробигаемся по всей очереди
	{
		tmp->data *= -1; //каждый элемент умножаем на -1
		tmp = tmp->prev; //передвигаем указатель
	}
	return res;
}


/*
1 - префиксные инкремент и декремент работают так, что мы сначала увеличиваем/уменьшаем, а потом выполняем остальные действия
постфикс наоборот, поэтому при постфиксной перегрузке мы должны запомнить исходное состояние объекта, далее делать с объектом что
хотим, а в конце НУЖНО вернуть исходное состояние объекта
2 - нельзя возвращать ссылки на локальные объекты
3 - чтобы компилятор понял гле префикс, а где постфикс в качестве параметра добавляется пустое int значение, если это значение
есть - то это постфикс, если его нет - префикс
4 - если оператор перегружается как метод, то сам объект не передается в качестве параметра, он присутствует как this,
если как дружественная функция, то необходимо передать объект в качестве параметра */

//префиксная форма, значит возвращаем ссылку на объект
//метод, значит объект, для которого вызван оператор присутствует как this
Queue & Queue::operator++()
{
	int val; //значние, на котрое будем увеличивать
	cout << "Введите значение для увеличения очереди: ";
	cin >> val;

	Node *tmp = tail; //указатель-помощник
	//пробигаемся по очереди, и к каждому значению прибавляем то, что ввели
	for (int i = 0; i < size; ++i)
	{
		tmp->data += val; //прибавляем введенное значение к значению из очереди
		tmp = tmp->prev; //передвигаем указатель
	}
	return *this; //возвращаем объект
}

//аналогично префиксному инкременту, только мы вичитаем введенное значение
Queue & Queue::operator--()
{
	int val;
	cout << "Введите значение для уменьшения очереди: ";
	cin >> val;

	Node *tmp = tail;
	for (int i = 0; i < size; ++i)
	{
		tmp->data -= val;
		tmp = tmp->prev;
	}
	return *this;
}

//постфикс, значит необходимо вернуть локальный объект
Queue Queue::operator++(int)
{
	Queue res(*this); //запомниаем исходное состояние объекта, а после делаем с ним, что хотим

	Node *tmp = tail; //указатель-помощник
	for (int i = 0; i < size; ++i) //к каждому значению очереди прибавляем размер очереди
	{
		tmp->data += size;
		tmp = tmp->prev; //передвигаем указатель на предыдущий элемент
	}
	return res; //возвращаем локальный объект, который хранит в себе изначальное состояние объекта this
}

//постфикс, значит необходимо вернуть локальный объект
Queue Queue::operator--(int)
{
	Queue res(*this);//запомниаем исходное состояние объекта, а после делаем с ним, что хотим

	Node *tmp = tail;//указатель-помощник
	for (int i = 0; i < size; ++i)//из каждого значения очереди вычитаем удвоинный размер очереди
	{
		tmp->data -= 2 * size;
		tmp = tmp->prev; //передвигаем указатель на предыдущий элемент
	}

	return res; //возвращаем локальный объект, который хранит в себе изначальное состояние объекта this
}

